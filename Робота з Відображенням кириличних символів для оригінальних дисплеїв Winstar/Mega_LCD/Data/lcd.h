
/* Автор:              Papandopala Papandopalavich
 * Имя файла:          Atmega16_LCD_LIB.c
 * Тип МК:			   Atmega16, Flash 16 Kbytes, SRAM 1 Kbytes, EEPROM 512 bytes.
 * Тактовая частота:   F_CPU 8000000 Гц
 * Дата:               28.06.2013 21:17:29
 * Версия ПО:          ATMEL STUDIO VERSION 6.1.2562
 * FUSES:              HIGH xx, LOW xx;
 * Описание:           Урезанная библиотека для работы с LCD дисплеями базирующимися на HD44780 
					   контроллерах. Данная библиотека работает по 4х и 8ми битной схеме подключения
					   LCD, поддерживает только вывод данных на дисплей*/

#include <inttypes.h>


#ifndef LCD
#define LCD

#if 1

//Указываем порт к которому подключены выводы дисплея LCD DB0...DB7.
#define DPIN  PINB
#define DDDR  DDRB
#define DPORT PORTB

//цифрами указываем номера выводов мк подключенные к дисплею.						
//Пины      МК  LCD   
	
#define DB4	4// DB4  
#define DB5	5// DB5
#define DB6	6// DB6
#define DB7	7// DB7 + BF флаг занятости дисплея.

//Указываем порт к которому подключены выводы дисплея E, RS, R/W.
#define CDDR  DDRB
#define CPORT PORTB

// Указываем номера пинов МК, к которым подключаем дисплей.
#define E	1	// E	 СТРОБ.
#define RW	2   // R/W   R/W=1 читаем из LCD, R/W=0 записываем в LCD.
#define RS	3 	// RS	 RS=0 посылаем команду в LCD, RS=1 посылаем данные в LCD.

#endif
//----------------------------------Настройки закончены---------------------------------
#if 1
//Пользовательские функции, ими пользуемся в программе.
                   
void LCDGotoXY(uint8_t,uint8_t);			             //Устанавливаем курсор в X, Y позицию
void LCDdata(uint8_t);						             //Вывести 1 символ на дисплей.
void LCDdataXY(uint8_t,uint8_t,uint8_t);	             //Вывести 1 символ на дисплей в X, Y позицию .
void LCDsendString(char*);                             //Вывести строку на дисплей
void LCDstringXY(char*,uint8_t,uint8_t);		             //Вывести строку на дисплей в позицию x,y
void LCDstring_of_sramXY(uint8_t*,uint8_t,uint8_t);			 //Вывести строку на дисплей в позицию x,y из ОЗУ		
void LCDstring_of_flashXY(const uint8_t*,uint8_t, uint8_t);//Вывести строку в позицию x,y из флеша

void LCDinit(void);							//Инициализация LCD  
void LCDblank(void);			//Сделать невидимым инфо на дисплее
void LCDnblank(void);			//Сделать видимой инфо на дисплее + отключение видимых курсоров.
void LCDclear(void);			//Очистить дисплей от инфо + курсор на позицию 0,0
void LCDcursor_bl(void);		//Включить мигающий курсор
void LCDcursor_on(void);		//Включить подчеркивающий курсор
void LCDcursor_vi(void);		//Включить оба курсора
void LCDcursorOFF(void);		//Выключить курсор (любой)
void LCDacr(void);				//Cчетчик адреса AC всегда будет смещаться на n+1
void LCDacl(void);				//Cчетчик адреса AC всегда будет смещаться на n-1
void LCDcursorl(void);			//Сместить курсор влево на 1 символ
void LCDcursorr(void);			//Сместить курсор вправо на 1 символ
void LCDcursorln(uint8_t);		//Сместить курсор влево на n символов
void LCDcursorrn(uint8_t);		//Сместить курсор вправо на n символов
void LCDscreenl(void);			//Сместить экран влево на 1 символ
void LCDscreenr(void);			//Сместить экран вправо на 1 символ
void LCDscreenln(uint8_t);		//Сместить экран влево на n символов
void LCDscreenrn(uint8_t);		//Сместить экран вправо на n символов
void LCDscreenL(void);			//С каждым новым символом экран будет смещаться влево
void LCDscreenR(void);			//С каждым новым символом экран будет смещаться вправо
void LCDresshift(void);			//Курсор в позицию 0,0 + сброс всех сдвигов, изображение остается


//Двухстрочный дисплей.
#define LINE0 0x00
#define LINE1 0x40

#endif

/*БИБЛИОТЕКА ДЛЯ ПЕРЕВОДА ДВОИЧНЫХ ЧИСЕЛ В СИМВОЛЫ И ВЫВОДА ИХ НА ЖКД*/
#if 1
/*здесь переопределяем функцию по выводу символа на экран или в терминал
если вывод не используется оставляем пустой макрос */

#define BCD_SendData(data) //LCD_WriteData(data)

/*отображать ноль в старших разрядах или нет. если закомментировать, то
ноль не будет отображаться*/

//#define MIRROR_NULL

/*использовать буфер или нет. если закомментировать, то запись в буфер
не будет производиться */

#define BCD_USE_BUF

/*переводить цифры в символы или оставлять в двоично-десятичном виде. если
закомментировать, то цифры будут сохраняться в двоично-десятичном виде, если
оставить то в символьном виде с завершающим нулевым символом*/

#define BCD_SYM

/*************************** пользовательские функции ***********************/

/*Взять указатель на буфер. Если буфер не используется,
будет возвращено нулевое значение */

uint8_t* BCD_GetPointerBuf(void);

/*Преобразование 8-ми разрядных двоичных чисел. Оптимизированные функции для 1, 2 и 3-ех
разрядных десятичных чисел. Если функции BCD_1(uint8_t value) передать 2 или 3-ех
разрядное десятичное число, она будет работать некорректно. То же самое относится
и к двум другим функциям*/

void BCD_1(uint8_t value);
void BCD_2(uint8_t value);
void BCD_3(uint8_t value);

/*Преобразование 16-ти разрядных двоичных чисел. Оптимизированные функции для 3, 4 и 5-и
разрядных десятичных чисел. Если функции BCD_3Int(uint16_t value) передать 4 или 5-и
разрядное десятичное число, она будет работать некорректно. То же самое относится
и к двум другим функциям*/

void BCD_3Int(uint16_t value);
void BCD_4Int(uint16_t value);
void BCD_5Int(uint16_t value);

/*Функции для преобразования 8, 16 и 32 разрядных двоичных чисел. Все функции
корректно работают со своими типами данных. */

void BCD_Uchar(uint8_t value);
void BCD_Uint(uint16_t value);
void BCD_Ulong(uint32_t value);

#endif

#endif

//Настройка конфигурации
/*
Настройка конфигурации включает в себя следующие шаги.

1. Подключение внешней библиотеки для вывода данных. 
Если этот функционал не используется, эту строчку можно закомментировать.

//подключаю библиотеку для вывода на lcd
#include "lcd_lib.h"

2. Переопределение функции вывода. Если этот функционал не используется макрос нужно оставить пустым.

//вывод не используется оставляем макрос пустым
#define BCD_SendData(data)

//вывод используется, переопределяем функцию
#define BCD_SendData(data) LCD_WriteData(data)

3. Отображение нуля в старших разрядах. Если закомментировать настройку ноль выводиться не будет, 
вместо него будет сохраняться символ пробела. Если оставить, ноль будет отображаться.

//при такой настройке BCD_Uchar(3) отобразит на экране 003
#define MIRROR_NULL

//если закомментировать BCD_Uchar(3) отобразит на экране 3
//#define MIRROR_NULL

4. Использование буфера.
В зависимости от настроек библиотеки, функции преобразования чисел могут сохранять результат в буфере 
в виде строки, которую потом можно передать какой-нибудь функции вывода. Если эту настройку 
закомментировать, то запись в буфер производиться не будет.

#define BCD_BUF_USE

5. Требуемый конечный результат. Библиотека позволяет переводить двоичные числа в двоично-десятичный вид 
или в символьный. Если данная настройка закомментирована используется двоично-десятичное представление, если нет, то символьное.

#define BCD_SYM

Описание функций

Общие функции для преобразования 8, 16 и 32 разрядных двоичных чисел.

void BCD_Uchar(uint8_t value) - преобразует числа от 0 до 255
void BCD_Uint(uint16_t value) - преобразует числа от 0 до 65535
void BCD_Ulong(uint32_t value) - преобразует числа от 0 до 4294967295

Пример

#define F_CPU 9600000UL
...
uint8_t count = 120;
uint16_t adc_value = 1020;
...
BCD_Uchar(count);
BCD_Uint(adc_value);
BCD_Ulong(F_CPU);

Функции для преобразования десятичных чисел заданной разрядности.

void BCD_1(uint8_t value) - преобразует числа от 0 до 9
void BCD_2(uint8_t value) - преобразует числа от 0 до 99
void BCD_3(uint8_t value) - преобразует числа от 0 до 255
void BCD_3Int(uint16_t value) - преобразует числа от 0 до 999
void BCD_4Int(uint16_t value) - преобразует числа от 0 до 9999
void BCD_5Int(uint16_t value) - преобразует числа от 0 до 65535

Пример

#define DATA 23
...
//переменная которая всегда < 10
uint8_t index = 0;

//счетчик до 999
uint8_t count;
...
BCD_1(index);
BCD_2(DATA);
BCD_3Int(count);

//а это неправильно
BCD_1(DATA);
BCD_3(count);

Функция для получения указателя на буфер, в котором сохраняется результат. Если буфер не используется, функция возвращает нулевой указатель.

uint8_t* BCD_GetPointerBuf(void);

Пример
//определяем переменную указатель на буфер
uint8_t* pBuf;

//инициализируем эту переменную
pBuf = BCD_GetPointerBuf();

//преобразуем число, а затем выводим строку на экран
BCD_3Int(counter);
LCD_SendStr(pBuf);*/
//Примеры использования команд
/*
LCDcommand(0b00101000);//Включаем 4х битный интерфейс приема/передачи и выбираем 5x8 точек.
LCDcommand(0b00000001);//Очистка экрана
LCDcommand(0b00000010);//Установка курсора в позицию 0,0 + сброс сдвигов
LCDcommand(0b00000110);//Вкл. инкримент счетчика адреса, движение изображения отк.
LCDcommand(0b00001100);//Включаем отображение на дисплее + без отображения курсора.

LCDdata('A');			//Вывели символ А
LCDGotoXY(6,1);			//Перевели курсор в седьмую позицию вторая строка.
LCDdata('B');			//И вывели символ В
LCDdataXY('Щ',0,0); Вывели символ Щ в позицию 0,0
LCDdata('у');
LCDdata('к');
LCDdata('а');
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
LCDGotoXY(1,1);			    //Перевели курсор в позицию 1,1.
LCDsendString("Пучеглазка");//Вывели  Пучеглазка
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
LCDstring("Красава Пучеглазка",0,1);//Вывели строку в позицию 0,1
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
Сперва объявим в озу uint8_t  text_1[]="Пучеглазка_3";
LCDstring_of_sram(text_1,0,0); а теперь выведем строку в позицию 0,0
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
Сперва объявим во флеш const uint8_t PROGMEM text_1[]="Пучеглазка_1";
LCDstring_of_flash(text_1,0,0); а теперь выведем строку в позицию 0,0
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~							 						 
*/

/*
Инициализация дисплея проводится таким образом.
1.Включаем питание.
2.После VCC >=4.5V ждем не менее 15 мсек.
3.Отправка команды 0x30 - 0b110000
4.Ждем не менее 4.1 мсек
5.Отправка команды 0x30
6.Ждем не менее 100 мксек
7.Отправка команды 0x30
Приведенные выше операции являются инициализирующими для LCD
и способны вывести дисплей в рабочее состояние из любого состояния.
8.Далее работаем с дисплеем в обычном режиме.

В исходном состоянии Е=0, R/W=0, RS - произвольное, DB0...DB7 высокий импеданс (HI).
Такое состояние должно сигналов Е=0, R/W=0 должно поддерживаться все время в пррмежутках между
операциями обмена данными с МК.

Дисплей настраиваем так:

int main(void)
{
	init();		//Инициализация МК.
	LCDinit();	//Инициализация LCD, эту функцию в первую очередь, потом все остальное.

	while(1)//Главный цикл программы.
	{
		
	}
}

Карта символов дисплея.
LCDGotoXY(3,1);
Цифра 3 означает четвертую позицию в любой строке. Если 0, то это первая позиция в любой строке.
цифра 1 означает нижнюю строку а 0 верхнюю.
|0,0|1,0|2,0|3,0|4,0|5,0|6,0|7,0| - первая строка
|0,1|1,1|2,1|3,1|4,1|5,1|6,1|7,1| - вторая строка

1  0  0
1 I/D S  
I/D - смещение счетчика адреса, 0-уменьшение 1-увеличение
S   - сдвиг содержимого экрана 0 содержимое не сдвигается, 1 сдвигается, 
      если I/D - 0 то вправо, если 1 то влево.
LCDcommand(100) - счетчик n-1, экран не сдвигается. Символы будут выводится  <-
LCDcommand(110) - счетчик n+1, экран не сдвигается. Символы будут выводится  ->
LCDcommand(101)	- счетчик n-1, изображение сдвигается вправо с каждым новым символом
LCDcommand(111) - счетчик n+1, изображение сдвигается влево с каждым новым символом
	   	   
1   0   0   0  0	   
1  S/C R/L  -  -     
S/C (screen/cursor) - 0 сдвигается курсор, 1 сдвигается экран.
R/L (right/left)    - 0 сдвиг влево, 1 сдвиг вправо. за одну команду на 1 сдвиг
*/